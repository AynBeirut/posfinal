// AUTO-GENERATED BUNDLED MIGRATIONS
// Generated: 2025-12-27T21:47:37.050Z
// DO NOT EDIT THIS FILE MANUALLY - Run bundle-migrations.js to regenerate

const BUNDLED_MIGRATIONS = {
    1: {
        version: 1,
        description: 'Initial schema with all 8 core tables + sync_queue + system_settings',
        sql: `-- ===================================
-- AYN BEIRUT POS - INITIAL SCHEMA
-- Migration 001: Create all base tables
-- ===================================

-- Schema version tracking table
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    description TEXT NOT NULL,
    applied_at INTEGER NOT NULL,
    applied_by TEXT
);

-- Sales table
CREATE TABLE IF NOT EXISTS sales (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    date TEXT NOT NULL,
    items TEXT NOT NULL,  -- JSON string
    totals TEXT NOT NULL, -- JSON string
    paymentMethod TEXT,
    customerInfo TEXT,    -- JSON string
    receiptNumber TEXT,
    cashierName TEXT,
    cashierId TEXT,
    notes TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_sales_timestamp ON sales(timestamp);
CREATE INDEX IF NOT EXISTS idx_sales_date ON sales(date);
CREATE INDEX IF NOT EXISTS idx_sales_cashierId ON sales(cashierId);
CREATE INDEX IF NOT EXISTS idx_sales_synced ON sales(synced);

-- Products table
CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT NOT NULL,
    price REAL NOT NULL,
    icon TEXT,
    barcode TEXT UNIQUE,
    stock INTEGER DEFAULT 0,
    description TEXT,
    createdAt INTEGER,
    updatedAt INTEGER,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
CREATE INDEX IF NOT EXISTS idx_products_barcode ON products(barcode);
CREATE INDEX IF NOT EXISTS idx_products_synced ON products(synced);

-- Users table
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role TEXT NOT NULL CHECK(role IN ('cashier', 'manager', 'admin')),
    name TEXT,
    email TEXT,
    permissions TEXT, -- JSON array of permissions
    createdAt INTEGER,
    lastLogin INTEGER
);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);

-- Activity logs table
CREATE TABLE IF NOT EXISTS activity (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    userId INTEGER NOT NULL,
    action TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    details TEXT, -- JSON string
    ipAddress TEXT,
    cashierId TEXT,
    FOREIGN KEY (userId) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_activity_userId ON activity(userId);
CREATE INDEX IF NOT EXISTS idx_activity_action ON activity(action);
CREATE INDEX IF NOT EXISTS idx_activity_timestamp ON activity(timestamp);

-- Stock history table
CREATE TABLE IF NOT EXISTS stock_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    oldStock INTEGER,
    newStock INTEGER NOT NULL,
    quantity INTEGER,
    reason TEXT,
    type TEXT CHECK(type IN ('add', 'remove', 'sale', 'adjustment')),
    userId INTEGER,
    cashierId TEXT,
    FOREIGN KEY (productId) REFERENCES products(id)
);
CREATE INDEX IF NOT EXISTS idx_stock_history_productId ON stock_history(productId);
CREATE INDEX IF NOT EXISTS idx_stock_history_timestamp ON stock_history(timestamp);

-- Customers table
CREATE TABLE IF NOT EXISTS customers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    phone TEXT,
    email TEXT,
    address TEXT,
    totalSpent REAL DEFAULT 0,
    totalPurchases INTEGER DEFAULT 0,
    lastPurchase INTEGER,
    notes TEXT,
    createdAt INTEGER,
    updatedAt INTEGER,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_customers_phone ON customers(phone);
CREATE INDEX IF NOT EXISTS idx_customers_name ON customers(name);
CREATE INDEX IF NOT EXISTS idx_customers_lastPurchase ON customers(lastPurchase);

-- Suppliers table (for purchasing system)
CREATE TABLE IF NOT EXISTS suppliers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    contactPerson TEXT,
    phone TEXT,
    email TEXT,
    address TEXT,
    paymentTerms TEXT,
    balance REAL DEFAULT 0,  -- Negative = we owe supplier, Positive = supplier owes us
    notes TEXT,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_suppliers_name ON suppliers(name);

-- Deliveries table (tracks stock receipts from suppliers)
CREATE TABLE IF NOT EXISTS deliveries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    supplierId INTEGER NOT NULL,
    deliveryRef TEXT,
    invoiceNumber TEXT,
    deliveryDate INTEGER NOT NULL,
    totalAmount REAL DEFAULT 0,
    notes TEXT,
    receivedBy TEXT,
    createdAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (supplierId) REFERENCES suppliers(id)
);
CREATE INDEX IF NOT EXISTS idx_deliveries_supplierId ON deliveries(supplierId);
CREATE INDEX IF NOT EXISTS idx_deliveries_deliveryDate ON deliveries(deliveryDate);

-- Delivery items table (line items in deliveries)
CREATE TABLE IF NOT EXISTS delivery_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    deliveryId INTEGER NOT NULL,
    productId INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    unitCost REAL NOT NULL,
    lineTotal REAL NOT NULL,
    FOREIGN KEY (deliveryId) REFERENCES deliveries(id),
    FOREIGN KEY (productId) REFERENCES products(id)
);
CREATE INDEX IF NOT EXISTS idx_delivery_items_deliveryId ON delivery_items(deliveryId);
CREATE INDEX IF NOT EXISTS idx_delivery_items_productId ON delivery_items(productId);

-- Supplier payments table (tracks payments to suppliers)
CREATE TABLE IF NOT EXISTS supplier_payments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    supplierId INTEGER NOT NULL,
    amount REAL NOT NULL,
    paymentMethod TEXT,
    reference TEXT,
    notes TEXT,
    paidBy TEXT,
    paidAt INTEGER NOT NULL,
    createdAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (supplierId) REFERENCES suppliers(id)
);
CREATE INDEX IF NOT EXISTS idx_supplier_payments_supplierId ON supplier_payments(supplierId);
CREATE INDEX IF NOT EXISTS idx_supplier_payments_paidAt ON supplier_payments(paidAt);

-- Categories table
CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    displayName TEXT NOT NULL,
    icon TEXT,
    sortOrder INTEGER DEFAULT 0,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE UNIQUE INDEX IF NOT EXISTS idx_categories_name ON categories(name);

-- Unpaid orders table
CREATE TABLE IF NOT EXISTS unpaid_orders (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    status TEXT DEFAULT 'unpaid' CHECK(status IN ('unpaid', 'paid', 'cancelled')),
    customerName TEXT,
    customerPhone TEXT,
    items TEXT NOT NULL,     -- JSON string
    totals TEXT NOT NULL,    -- JSON string
    createdDate TEXT NOT NULL,
    paidDate TEXT,
    notes TEXT,
    cashierId TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_unpaid_orders_timestamp ON unpaid_orders(timestamp);
CREATE INDEX IF NOT EXISTS idx_unpaid_orders_customerName ON unpaid_orders(customerName);
CREATE INDEX IF NOT EXISTS idx_unpaid_orders_status ON unpaid_orders(status);
CREATE INDEX IF NOT EXISTS idx_unpaid_orders_cashierId ON unpaid_orders(cashierId);

-- Sync queue table (for failed operations)
CREATE TABLE IF NOT EXISTS sync_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    operation TEXT NOT NULL CHECK(operation IN ('INSERT', 'UPDATE', 'DELETE')),
    table_name TEXT NOT NULL,
    data TEXT NOT NULL, -- JSON string
    timestamp INTEGER NOT NULL,
    retry_count INTEGER DEFAULT 0,
    last_error TEXT,
    synced INTEGER DEFAULT 0
);
CREATE INDEX IF NOT EXISTS idx_sync_queue_synced ON sync_queue(synced);
CREATE INDEX IF NOT EXISTS idx_sync_queue_timestamp ON sync_queue(timestamp);

-- System settings table
CREATE TABLE IF NOT EXISTS system_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at INTEGER NOT NULL
);

-- Insert initial schema version
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (1, 'Initial schema with all 8 core tables + sync_queue + system_settings', strftime('%s', 'now'), 'system');

-- Insert default categories
INSERT INTO categories (name, displayName, icon, sortOrder) VALUES
('electronics', 'Electronics', 'üíª', 1),
('accessories', 'Accessories', 'üéß', 2),
('software', 'Software', 'üìÄ', 3),
('other', 'Other', 'üì¶', 4);

-- Insert default users (admin and cashier)
INSERT INTO users (id, username, password, name, role, createdAt) VALUES
(1, 'admin', 'admin123', 'Administrator', 'admin', strftime('%s', 'now')),
(2, 'manager', 'manager123', 'Manager', 'manager', strftime('%s', 'now')),
(3, 'cashier', 'cashier123', 'Cashier', 'cashier', strftime('%s', 'now'));
`
    },
    2: {
        version: 2,
        description: 'Add phonebook, bill_payments, bill_types, company_info, app_settings',
        sql: `-- ===================================
-- AYN BEIRUT POS - ENHANCED FEATURES
-- Migration 002: Phonebook, Bill Payments, User Management, Settings
-- ===================================

-- Phonebook table (Client registry)
CREATE TABLE IF NOT EXISTS phonebook (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    address TEXT,
    notes TEXT,
    totalSpent REAL DEFAULT 0,
    lastVisit INTEGER,
    createdAt INTEGER NOT NULL,
    createdBy INTEGER,
    cashierId TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_phonebook_phone ON phonebook(phone);
CREATE INDEX IF NOT EXISTS idx_phonebook_name ON phonebook(name);
CREATE INDEX IF NOT EXISTS idx_phonebook_lastVisit ON phonebook(lastVisit);
CREATE INDEX IF NOT EXISTS idx_phonebook_synced ON phonebook(synced);

-- Bill Payments table
CREATE TABLE IF NOT EXISTS bill_payments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    billType INTEGER NOT NULL,
    billNumber TEXT,
    customerName TEXT,
    customerPhone TEXT,
    amount REAL NOT NULL,
    paymentMethod TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    receiptNumber TEXT,
    cashierId TEXT NOT NULL,
    notes TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);
CREATE INDEX IF NOT EXISTS idx_bill_payments_timestamp ON bill_payments(timestamp);
CREATE INDEX IF NOT EXISTS idx_bill_payments_billType ON bill_payments(billType);
CREATE INDEX IF NOT EXISTS idx_bill_payments_customerPhone ON bill_payments(customerPhone);
CREATE INDEX IF NOT EXISTS idx_bill_payments_cashierId ON bill_payments(cashierId);
CREATE INDEX IF NOT EXISTS idx_bill_payments_synced ON bill_payments(synced);

-- Bill Types table (Default + Custom)
CREATE TABLE IF NOT EXISTS bill_types (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    icon TEXT NOT NULL,
    isDefault INTEGER DEFAULT 0,
    sortOrder INTEGER DEFAULT 0,
    isActive INTEGER DEFAULT 1,
    createdBy INTEGER,
    createdAt INTEGER,
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_bill_types_isActive ON bill_types(isActive);
CREATE INDEX IF NOT EXISTS idx_bill_types_sortOrder ON bill_types(sortOrder);

-- Insert default bill types
INSERT INTO bill_types (name, icon, isDefault, sortOrder, isActive) VALUES
('Electricity', 'üí°', 1, 1, 1),
('Water', 'üíß', 1, 2, 1),
('Phone', 'üì±', 1, 3, 1),
('Internet', 'üåê', 1, 4, 1),
('Gas', 'üî•', 1, 5, 1),
('Municipality', 'üèõÔ∏è', 1, 6, 1),
('Other', 'üìÑ', 1, 7, 1);

-- Company Info table (Single record for receipt header/footer)
CREATE TABLE IF NOT EXISTS company_info (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    companyName TEXT,
    phone TEXT,
    website TEXT,
    email TEXT,
    taxId TEXT,
    address TEXT,
    logo TEXT,
    updatedAt INTEGER,
    updatedBy INTEGER,
    FOREIGN KEY (updatedBy) REFERENCES users(id)
);

-- Insert empty company info record
INSERT INTO company_info (id, companyName, updatedAt) VALUES (1, NULL, strftime('%s', 'now'));

-- App Settings table (VPS config, sync settings, etc)
CREATE TABLE IF NOT EXISTS app_settings (
    key TEXT PRIMARY KEY,
    value TEXT,
    category TEXT,
    updated_at INTEGER NOT NULL
);

-- Insert default app settings
INSERT INTO app_settings (key, value, category, updated_at) VALUES
('vps_endpoint', '', 'sync', strftime('%s', 'now')),
('api_key', '', 'sync', strftime('%s', 'now')),
('branch_id', '', 'sync', strftime('%s', 'now')),
('app_mode', 'sub', 'sync', strftime('%s', 'now')),
('sync_interval_minutes', '5', 'sync', strftime('%s', 'now')),
('sync_retry_count', '5', 'sync', strftime('%s', 'now')),
('backup_retention_days', '90', 'backup', strftime('%s', 'now')),
('backup_minimum_keep', '3', 'backup', strftime('%s', 'now'));

-- Update schema version
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (2, 'Enhanced features: Phonebook, Bill Payments, User Management, Company Info, App Settings', strftime('%s', 'now'), 'system');
`
    },
    3: {
        version: 3,
        description: 'Enhanced phonebook with categories, birthday, balance, notes, and history',
        sql: `-- ===================================
-- AYN BEIRUT POS - PHONEBOOK ENHANCEMENTS
-- Migration 003: Add phonebook enhancements with data preservation
-- ===================================

-- Create new phonebook table with all columns
CREATE TABLE IF NOT EXISTS phonebook_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    phone TEXT NOT NULL UNIQUE,
    email TEXT,
    address TEXT,
    category TEXT DEFAULT 'Regular',
    birthday TEXT,
    balance REAL DEFAULT 0,
    notes TEXT,
    totalSpent REAL DEFAULT 0,
    visitCount INTEGER DEFAULT 0,
    lastVisit INTEGER,
    createdBy TEXT,
    cashierId TEXT,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);

-- Copy data from old table if it exists
INSERT INTO phonebook_new (id, name, phone, email, address, notes, totalSpent, lastVisit, createdBy, cashierId, createdAt, synced, synced_at)
SELECT id, name, phone, email, address, notes, totalSpent, lastVisit, createdBy, cashierId, createdAt, synced, synced_at
FROM phonebook;

-- Drop old table
DROP TABLE phonebook;

-- Rename new table
ALTER TABLE phonebook_new RENAME TO phonebook;

-- Create indexes
CREATE UNIQUE INDEX IF NOT EXISTS idx_phonebook_phone ON phonebook(phone);
CREATE INDEX IF NOT EXISTS idx_phonebook_name ON phonebook(name);
CREATE INDEX IF NOT EXISTS idx_phonebook_category ON phonebook(category);
CREATE INDEX IF NOT EXISTS idx_phonebook_balance ON phonebook(balance);
CREATE INDEX IF NOT EXISTS idx_phonebook_lastVisit ON phonebook(lastVisit);

-- Create phonebook history table for tracking interactions
CREATE TABLE IF NOT EXISTS phonebook_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    clientId INTEGER NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('sale', 'payment', 'note', 'edit', 'visit')),
    description TEXT NOT NULL,
    amount REAL,
    metadata TEXT,
    createdBy TEXT,
    cashierId TEXT,
    createdAt INTEGER NOT NULL,
    FOREIGN KEY (clientId) REFERENCES phonebook(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_phonebook_history_clientId ON phonebook_history(clientId);
CREATE INDEX IF NOT EXISTS idx_phonebook_history_type ON phonebook_history(type);
CREATE INDEX IF NOT EXISTS idx_phonebook_history_createdAt ON phonebook_history(createdAt);

-- Update schema version
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (3, 'Enhanced phonebook with categories, birthday, balance, notes, and history tracking', strftime('%s', 'now'), 'system');

`
    },
    4: {
        version: 4,
        description: 'Add cost column to products table for weighted average cost tracking',
        sql: `-- ===================================
-- AYN BEIRUT POS - ADD PRODUCT COST COLUMN
-- Migration 004: Add cost column to products table for weighted average cost tracking
-- ===================================

-- Create new products table with cost column
CREATE TABLE IF NOT EXISTS products_new (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT NOT NULL,
    price REAL NOT NULL,
    cost REAL DEFAULT 0,
    icon TEXT,
    barcode TEXT UNIQUE,
    stock INTEGER DEFAULT 0,
    description TEXT,
    createdAt INTEGER,
    updatedAt INTEGER,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);

-- Copy data from old table
INSERT INTO products_new (id, name, category, price, icon, barcode, stock, description, createdAt, updatedAt, synced, synced_at)
SELECT id, name, category, price, icon, barcode, stock, description, createdAt, updatedAt, synced, synced_at
FROM products;

-- Drop old table
DROP TABLE products;

-- Rename new table
ALTER TABLE products_new RENAME TO products;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
CREATE INDEX IF NOT EXISTS idx_products_barcode ON products(barcode);
CREATE INDEX IF NOT EXISTS idx_products_synced ON products(synced);
`
    },
    5: {
        version: 5,
        description: 'Fix AUTOINCREMENT for suppliers, deliveries, delivery_items, supplier_payments tables',
        sql: `-- ===================================
-- AYN BEIRUT POS - FIX SUPPLIERS/DELIVERIES AUTOINCREMENT
-- Migration 005: Recreate suppliers, deliveries, delivery_items, supplier_payments with proper AUTOINCREMENT
-- ===================================

-- Recreate suppliers table
CREATE TABLE IF NOT EXISTS suppliers_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    contactPerson TEXT,
    phone TEXT,
    email TEXT,
    address TEXT,
    paymentTerms TEXT,
    balance REAL DEFAULT 0,
    notes TEXT,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);

-- Copy existing supplier data if table exists
INSERT INTO suppliers_new (id, name, contactPerson, phone, email, address, paymentTerms, balance, notes, createdAt, updatedAt, synced, synced_at)
SELECT id, name, contactPerson, phone, email, address, paymentTerms, balance, notes, createdAt, updatedAt, synced, synced_at
FROM suppliers WHERE 1;

-- Drop old and rename
DROP TABLE IF EXISTS suppliers;
ALTER TABLE suppliers_new RENAME TO suppliers;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_suppliers_name ON suppliers(name);

-- Recreate deliveries table
CREATE TABLE IF NOT EXISTS deliveries_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    supplierId INTEGER NOT NULL,
    deliveryRef TEXT,
    invoiceNumber TEXT,
    deliveryDate INTEGER NOT NULL,
    totalAmount REAL DEFAULT 0,
    notes TEXT,
    receivedBy TEXT,
    createdAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (supplierId) REFERENCES suppliers(id)
);

-- Copy existing delivery data if table exists
INSERT INTO deliveries_new (id, supplierId, deliveryRef, invoiceNumber, deliveryDate, totalAmount, notes, receivedBy, createdAt, synced, synced_at)
SELECT id, supplierId, deliveryRef, invoiceNumber, deliveryDate, totalAmount, notes, receivedBy, createdAt, synced, synced_at
FROM deliveries WHERE 1;

-- Drop old and rename
DROP TABLE IF EXISTS deliveries;
ALTER TABLE deliveries_new RENAME TO deliveries;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_deliveries_supplierId ON deliveries(supplierId);
CREATE INDEX IF NOT EXISTS idx_deliveries_deliveryDate ON deliveries(deliveryDate);

-- Recreate delivery_items table
CREATE TABLE IF NOT EXISTS delivery_items_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    deliveryId INTEGER NOT NULL,
    productId INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    unitCost REAL NOT NULL,
    lineTotal REAL NOT NULL,
    FOREIGN KEY (deliveryId) REFERENCES deliveries(id),
    FOREIGN KEY (productId) REFERENCES products(id)
);

-- Copy existing data
INSERT INTO delivery_items_new (id, deliveryId, productId, quantity, unitCost, lineTotal)
SELECT id, deliveryId, productId, quantity, unitCost, lineTotal
FROM delivery_items WHERE 1;

-- Drop old and rename
DROP TABLE IF EXISTS delivery_items;
ALTER TABLE delivery_items_new RENAME TO delivery_items;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_delivery_items_deliveryId ON delivery_items(deliveryId);
CREATE INDEX IF NOT EXISTS idx_delivery_items_productId ON delivery_items(productId);

-- Recreate supplier_payments table
CREATE TABLE IF NOT EXISTS supplier_payments_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    supplierId INTEGER NOT NULL,
    amount REAL NOT NULL,
    paymentMethod TEXT,
    reference TEXT,
    notes TEXT,
    paidBy TEXT,
    paidAt INTEGER NOT NULL,
    createdAt INTEGER NOT NULL,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (supplierId) REFERENCES suppliers(id)
);

-- Copy existing data
INSERT INTO supplier_payments_new (id, supplierId, amount, paymentMethod, reference, notes, paidBy, paidAt, createdAt, synced, synced_at)
SELECT id, supplierId, amount, paymentMethod, reference, notes, paidBy, paidAt, createdAt, synced, synced_at
FROM supplier_payments WHERE 1;

-- Drop old and rename
DROP TABLE IF EXISTS supplier_payments;
ALTER TABLE supplier_payments_new RENAME TO supplier_payments;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_supplier_payments_supplierId ON supplier_payments(supplierId);
CREATE INDEX IF NOT EXISTS idx_supplier_payments_paidAt ON supplier_payments(paidAt);
`
    },
    6: {
        version: 6,
        description: 'Add type column to products table (item/service) and service-specific fields',
        sql: `-- ===================================
-- Migration 005: Add type column to products table
-- Description: Add product type (item/service) and service-specific fields
-- ===================================

-- Add type column (item or service)
ALTER TABLE products ADD COLUMN type TEXT DEFAULT 'item' CHECK(type IN ('item', 'service'));

-- Add service-specific fields
ALTER TABLE products ADD COLUMN hourlyEnabled INTEGER DEFAULT 0;
ALTER TABLE products ADD COLUMN firstHourRate REAL DEFAULT 0;
ALTER TABLE products ADD COLUMN additionalHourRate REAL DEFAULT 0;

-- Create index on type for filtering
CREATE INDEX IF NOT EXISTS idx_products_type ON products(type);
`
    },
    7: {
        version: 7,
        description: 'Update existing service products to correct type and hourly rates',
        sql: `-- Data migration: Update existing service products to correct type
-- Services are products in 'software' category or maintenance/repair related

UPDATE products 
SET type = 'service',
    hourlyEnabled = 1,
    firstHourRate = CASE 
        WHEN name LIKE '%repair%' OR name LIKE '%maintenance%' THEN 50.00
        WHEN name LIKE '%consult%' THEN 75.00
        WHEN name LIKE '%recovery%' THEN 100.00
        ELSE price
    END,
    additionalHourRate = CASE 
        WHEN name LIKE '%repair%' OR name LIKE '%maintenance%' THEN 35.00
        WHEN name LIKE '%consult%' THEN 50.00
        WHEN name LIKE '%recovery%' THEN 60.00
        ELSE price * 0.7
    END
WHERE category = 'software' 
   OR name LIKE '%service%' 
   OR name LIKE '%repair%' 
   OR name LIKE '%maintenance%'
   OR name LIKE '%installation%'
   OR name LIKE '%consultation%'
   OR name LIKE '%recovery%';

-- For simple services without hourly billing, disable hourly mode
UPDATE products
SET hourlyEnabled = 0,
    firstHourRate = 0,
    additionalHourRate = 0
WHERE type = 'service' 
  AND (name LIKE '%installation%' OR name NOT LIKE '%repair%' AND name NOT LIKE '%consult%' AND name NOT LIKE '%recovery%');
`
    },
    8: {
        version: 8,
        description: 'Add cash drawer shift management and bank transfer tables',
        sql: `-- Add cash drawer shift management
-- Tracks cashier shifts, opening/closing cash, and reconciliation

CREATE TABLE IF NOT EXISTS cash_shifts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    cashierId TEXT NOT NULL,
    cashierName TEXT NOT NULL,
    openTime INTEGER NOT NULL,
    closeTime INTEGER,
    openingCash REAL NOT NULL,
    closingCash REAL,
    expectedCash REAL,
    difference REAL,
    totalSales REAL DEFAULT 0,
    totalCash REAL DEFAULT 0,
    totalCard REAL DEFAULT 0,
    totalMobile REAL DEFAULT 0,
    cashRefunds REAL DEFAULT 0,
    cashExpenses REAL DEFAULT 0,
    status TEXT DEFAULT 'open' CHECK(status IN ('open', 'closed')),
    notes TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);

-- Add bank transfers table for cash-to-bank movements
CREATE TABLE IF NOT EXISTS bank_transfers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    shiftId INTEGER,
    amount REAL NOT NULL,
    bankAccount TEXT NOT NULL,
    reference TEXT,
    transferredBy TEXT NOT NULL,
    transferredByRole TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    notes TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (shiftId) REFERENCES cash_shifts(id)
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_cash_shifts_cashier ON cash_shifts(cashierId);
CREATE INDEX IF NOT EXISTS idx_cash_shifts_status ON cash_shifts(status);
CREATE INDEX IF NOT EXISTS idx_cash_shifts_open_time ON cash_shifts(openTime);
CREATE INDEX IF NOT EXISTS idx_bank_transfers_shift ON bank_transfers(shiftId);
CREATE INDEX IF NOT EXISTS idx_bank_transfers_timestamp ON bank_transfers(timestamp);
`
    },
    9: {
        version: 9,
        description: 'Add refunds table and order modification tracking',
        sql: `-- Add refunds table for tracking all refund transactions

CREATE TABLE IF NOT EXISTS refunds (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    saleId INTEGER NOT NULL,
    originalSaleDate TEXT,
    refundAmount REAL NOT NULL,
    refundType TEXT DEFAULT 'full' CHECK(refundType IN ('full', 'partial')),
    refundItems TEXT NOT NULL, -- JSON array of refunded items
    reason TEXT,
    approvedBy TEXT NOT NULL,
    approverUsername TEXT NOT NULL,
    approverRole TEXT NOT NULL,
    processedBy TEXT NOT NULL,
    timestamp INTEGER NOT NULL,
    receiptNumber TEXT,
    paymentMethod TEXT, -- How refund was issued (cash, card, etc)
    notes TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    FOREIGN KEY (saleId) REFERENCES sales(id)
);

-- Add modification tracking to unpaid_orders (check if columns don't exist first)
-- SQLite doesn't support IF NOT EXISTS for ALTER TABLE ADD COLUMN
-- So we'll use a different approach: check pragma and add only if missing

-- Check if modified column exists, if not create a new table with it
CREATE TABLE IF NOT EXISTS unpaid_orders_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER NOT NULL,
    status TEXT DEFAULT 'unpaid',
    customerName TEXT,
    customerPhone TEXT,
    items TEXT NOT NULL,
    totals TEXT NOT NULL,
    createdDate TEXT,
    paidDate TEXT,
    notes TEXT,
    cashierId TEXT,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER,
    modified INTEGER DEFAULT 0,
    modifiedAt INTEGER,
    modifiedBy TEXT
);

-- Copy data from old table if it exists and is different
-- For fresh installs, unpaid_orders won't have modified/modifiedAt/modifiedBy columns
INSERT OR IGNORE INTO unpaid_orders_new 
    (id, timestamp, status, customerName, customerPhone, items, totals, createdDate, paidDate, notes, cashierId, synced, synced_at, modified, modifiedAt, modifiedBy)
SELECT 
    id, timestamp, status, customerName, customerPhone, items, totals, createdDate, paidDate, notes, cashierId, synced, synced_at,
    0 as modified,    -- Default value for fresh installs
    NULL as modifiedAt,
    NULL as modifiedBy
FROM unpaid_orders;

-- Drop old table and rename new one
DROP TABLE IF EXISTS unpaid_orders;
ALTER TABLE unpaid_orders_new RENAME TO unpaid_orders;

-- Create indexes for refunds
CREATE INDEX IF NOT EXISTS idx_refunds_sale ON refunds(saleId);
CREATE INDEX IF NOT EXISTS idx_refunds_timestamp ON refunds(timestamp);
CREATE INDEX IF NOT EXISTS idx_refunds_approver ON refunds(approvedBy);
CREATE INDEX IF NOT EXISTS idx_unpaid_orders_modified ON unpaid_orders(modified);
`
    },
    10: {
        version: 10,
        description: 'Add isActive column to users table for user status management',
        sql: `-- ===================================
-- Migration 009: Add isActive column to users table
-- ===================================

-- Add isActive column to users table (default to 1 = active)
ALTER TABLE users ADD COLUMN isActive INTEGER DEFAULT 1;

-- Update any existing users to be active (in case column was added with NULL)
UPDATE users SET isActive = 1 WHERE isActive IS NULL;

-- Update schema version
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (10, 'Add isActive column to users table', strftime('%s', 'now') * 1000, 'System');
`
    },
    11: {
        version: 11,
        description: 'Add sequential receipt numbering system (SALE-000001, REF-000001)',
        sql: `-- Migration 011: Add Sequential Receipt Numbering System
-- This migration initializes receipt counters and auto-assigns receipt numbers to existing sales

-- Initialize receipt counters in system_settings
INSERT OR REPLACE INTO system_settings (key, value, updated_at)
VALUES ('sale_receipt_counter', '0', strftime('%s', 'now') * 1000);

INSERT OR REPLACE INTO system_settings (key, value, updated_at)
VALUES ('refund_receipt_counter', '0', strftime('%s', 'now') * 1000);

-- Auto-assign receipt numbers to existing sales without receipt numbers
-- Sales will be numbered in chronological order: SALE-000001, SALE-000002, etc.
UPDATE sales
SET receiptNumber = 'SALE-' || substr('000000' || (
    SELECT COUNT(*) + 1
    FROM sales s2
    WHERE s2.timestamp < sales.timestamp
), -6)
WHERE receiptNumber IS NULL;

-- Update the counter to match the highest assigned number
UPDATE system_settings
SET value = CAST((SELECT COUNT(*) FROM sales WHERE receiptNumber IS NOT NULL) AS TEXT),
    updated_at = strftime('%s', 'now') * 1000
WHERE key = 'sale_receipt_counter';

-- Log migration completion in sync_queue for audit trail
INSERT INTO sync_queue (operation, table_name, data, timestamp, synced)
VALUES (
    'INSERT',
    'system_settings',
    '{"migration": "011-add-receipt-numbering", "sale_counter": ' || (SELECT value FROM system_settings WHERE key = 'sale_receipt_counter') || ', "refund_counter": ' || (SELECT value FROM system_settings WHERE key = 'refund_receipt_counter') || '}',
    strftime('%s', 'now') * 1000,
    0
);
`
    },
    12: {
        version: 12,
        description: 'Add future features: raw materials, recipes, staff, approvals, expenses, dining areas',
        sql: `-- ===================================
-- AYN BEIRUT POS - FUTURE FEATURES PLACEHOLDERS
-- Migration 012: Database structure for Store & Restaurant modes
-- ===================================
-- PREPARES DATABASE FOR FUTURE IMPLEMENTATION
-- Supports both retail store and restaurant/cafe operations
-- ===================================

-- ===================================
-- 1. RAW MATERIALS & INVENTORY
-- ===================================
-- Raw materials purchased from suppliers
-- Used to create finished menu items (sandwiches, coffee, etc.)

CREATE TABLE IF NOT EXISTS raw_materials (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE, -- e.g., 'RM001', 'RM002'
    name TEXT NOT NULL, -- e.g., 'Bread - White Loaf', 'Coffee Beans - Arabica'
    category TEXT, -- 'Ingredients', 'Beverages', 'Packaging', 'Cleaning'
    unit TEXT NOT NULL, -- 'kg', 'liter', 'piece', 'box', 'bag'
    currentStock REAL DEFAULT 0,
    minStock REAL DEFAULT 0, -- Reorder alert threshold
    maxStock REAL DEFAULT 0, -- Maximum storage capacity
    costPerUnit REAL DEFAULT 0, -- Purchase cost
    supplierId INTEGER,
    storageLocation TEXT, -- 'Main Stock', 'Kitchen', 'Bar', 'Freezer', 'Dry Storage'
    expiryTracking INTEGER DEFAULT 0, -- 1 if needs expiry date monitoring
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER,
    notes TEXT,
    FOREIGN KEY (supplierId) REFERENCES suppliers(id),
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_raw_materials_category ON raw_materials(category);
CREATE INDEX IF NOT EXISTS idx_raw_materials_supplier ON raw_materials(supplierId);
CREATE INDEX IF NOT EXISTS idx_raw_materials_active ON raw_materials(isActive);
CREATE INDEX IF NOT EXISTS idx_raw_materials_storage ON raw_materials(storageLocation);

-- Track all raw material movements
CREATE TABLE IF NOT EXISTS raw_material_transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    rawMaterialId INTEGER NOT NULL,
    transactionType TEXT NOT NULL, -- 'purchase', 'production_use', 'waste', 'transfer', 'adjustment', 'return'
    quantity REAL NOT NULL, -- Positive = increase stock, Negative = decrease stock
    balanceAfter REAL NOT NULL, -- Stock balance after this transaction
    unitCost REAL,
    totalValue REAL,
    fromLocation TEXT, -- For transfers
    toLocation TEXT, -- For transfers
    referenceType TEXT, -- 'delivery', 'recipe_production', 'waste_report', 'manual_adjustment'
    referenceId INTEGER, -- Links to related record
    timestamp INTEGER NOT NULL,
    userId INTEGER NOT NULL,
    notes TEXT,
    FOREIGN KEY (rawMaterialId) REFERENCES raw_materials(id),
    FOREIGN KEY (userId) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_raw_transactions_material ON raw_material_transactions(rawMaterialId);
CREATE INDEX IF NOT EXISTS idx_raw_transactions_type ON raw_material_transactions(transactionType);
CREATE INDEX IF NOT EXISTS idx_raw_transactions_timestamp ON raw_material_transactions(timestamp);
CREATE INDEX IF NOT EXISTS idx_raw_transactions_reference ON raw_material_transactions(referenceType, referenceId);

-- ===================================
-- 2. PRODUCTION STATIONS & RECIPES
-- ===================================
-- Stations where items are prepared (Kitchen, Bar, etc.)

CREATE TABLE IF NOT EXISTS production_stations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE, -- 'Kitchen', 'Bar', 'Grill', 'Bakery', 'Cold Station'
    code TEXT UNIQUE, -- 'KTCH', 'BAR', 'GRLL'
    description TEXT,
    isActive INTEGER DEFAULT 1,
    displayOrder INTEGER DEFAULT 0,
    createdAt INTEGER NOT NULL
);

-- Recipes: How to make menu items from raw materials
-- Created by Admin/Manager, linked to menu items (products)
CREATE TABLE IF NOT EXISTS recipes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL, -- The menu item this recipe produces
    recipeName TEXT NOT NULL,
    stationId INTEGER NOT NULL, -- Which station prepares this (Kitchen, Bar, etc.)
    servingSize REAL DEFAULT 1, -- Portions produced
    preparationTime INTEGER, -- Minutes
    instructions TEXT, -- Cooking/preparation instructions
    costPerServing REAL DEFAULT 0, -- Auto-calculated from ingredients
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER NOT NULL,
    FOREIGN KEY (productId) REFERENCES products(id),
    FOREIGN KEY (stationId) REFERENCES production_stations(id),
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_recipes_product ON recipes(productId);
CREATE INDEX IF NOT EXISTS idx_recipes_station ON recipes(stationId);
CREATE INDEX IF NOT EXISTS idx_recipes_active ON recipes(isActive);

-- Recipe ingredients: Which raw materials and how much
CREATE TABLE IF NOT EXISTS recipe_ingredients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    recipeId INTEGER NOT NULL,
    rawMaterialId INTEGER NOT NULL,
    quantityNeeded REAL NOT NULL, -- Amount needed per serving
    unit TEXT NOT NULL,
    cost REAL DEFAULT 0, -- Cost of this ingredient in recipe
    isOptional INTEGER DEFAULT 0,
    preparationNotes TEXT, -- e.g., 'chopped', 'grilled', 'shredded'
    FOREIGN KEY (recipeId) REFERENCES recipes(id) ON DELETE CASCADE,
    FOREIGN KEY (rawMaterialId) REFERENCES raw_materials(id)
);
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_recipe ON recipe_ingredients(recipeId);
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_material ON recipe_ingredients(rawMaterialId);

-- Production log: Track when items are made
-- Auto-deducts raw materials when production is recorded
CREATE TABLE IF NOT EXISTS production_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    recipeId INTEGER NOT NULL,
    productId INTEGER NOT NULL,
    quantityProduced REAL NOT NULL,
    stationId INTEGER NOT NULL,
    producedBy INTEGER, -- Staff member who made it
    productionDate INTEGER NOT NULL,
    materialsCost REAL DEFAULT 0, -- Total raw materials cost
    status TEXT DEFAULT 'completed', -- 'in_progress', 'completed', 'cancelled', 'wasted'
    saleId INTEGER, -- Link to sale if sold immediately
    notes TEXT,
    FOREIGN KEY (recipeId) REFERENCES recipes(id),
    FOREIGN KEY (productId) REFERENCES products(id),
    FOREIGN KEY (stationId) REFERENCES production_stations(id),
    FOREIGN KEY (producedBy) REFERENCES staff(id),
    FOREIGN KEY (saleId) REFERENCES sales(id)
);
CREATE INDEX IF NOT EXISTS idx_production_recipe ON production_log(recipeId);
CREATE INDEX IF NOT EXISTS idx_production_station ON production_log(stationId);
CREATE INDEX IF NOT EXISTS idx_production_date ON production_log(productionDate);
CREATE INDEX IF NOT EXISTS idx_production_status ON production_log(status);

-- ===================================
-- 3. KITCHEN/BAR ORDER DISPLAY SYSTEM
-- ===================================
-- Orders sent to Kitchen/Bar for preparation

CREATE TABLE IF NOT EXISTS station_orders (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    orderId INTEGER NOT NULL, -- Link to unpaid_orders or sales
    orderType TEXT DEFAULT 'sale', -- 'sale', 'unpaid_order'
    stationId INTEGER NOT NULL,
    productId INTEGER NOT NULL,
    productName TEXT NOT NULL,
    quantity REAL NOT NULL,
    specialInstructions TEXT, -- Customer requests (no onions, extra cheese, etc.)
    priority TEXT DEFAULT 'normal', -- 'low', 'normal', 'high', 'urgent'
    status TEXT DEFAULT 'pending', -- 'pending', 'preparing', 'ready', 'served', 'cancelled'
    tableNumber TEXT, -- For restaurant mode
    serverName TEXT, -- Waiter/bartender who took order
    receivedAt INTEGER NOT NULL, -- When order came in
    startedAt INTEGER, -- When preparation started
    completedAt INTEGER, -- When item ready
    servedAt INTEGER, -- When delivered to customer
    preparedBy INTEGER, -- Staff who prepared it
    FOREIGN KEY (stationId) REFERENCES production_stations(id),
    FOREIGN KEY (productId) REFERENCES products(id),
    FOREIGN KEY (preparedBy) REFERENCES staff(id)
);
CREATE INDEX IF NOT EXISTS idx_station_orders_order ON station_orders(orderId, orderType);
CREATE INDEX IF NOT EXISTS idx_station_orders_station ON station_orders(stationId);
CREATE INDEX IF NOT EXISTS idx_station_orders_status ON station_orders(status);
CREATE INDEX IF NOT EXISTS idx_station_orders_received ON station_orders(receivedAt);

-- ===================================
-- 4. MANAGER APPROVAL SYSTEM
-- ===================================
-- Central approval queue for various actions

CREATE TABLE IF NOT EXISTS approval_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    requestType TEXT NOT NULL, -- 'purchase_order', 'supplier_payment', 'refund', 'bank_transfer', 'staff_attendance', 'salary_payment', 'expense', 'price_change', 'discount'
    referenceType TEXT, -- 'delivery', 'payment', 'refund', 'staff_payment', etc.
    referenceId INTEGER, -- ID of item needing approval
    requestData TEXT, -- JSON with all request details
    amount REAL, -- For financial approvals
    requestedBy INTEGER NOT NULL,
    requestedAt INTEGER NOT NULL,
    status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'auto_approved', 'cancelled'
    reviewedBy INTEGER,
    reviewedAt INTEGER,
    reviewNotes TEXT,
    priority TEXT DEFAULT 'normal', -- 'low', 'normal', 'high', 'urgent'
    expiresAt INTEGER, -- Optional: request auto-cancels after this time
    FOREIGN KEY (requestedBy) REFERENCES users(id),
    FOREIGN KEY (reviewedBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_approval_type ON approval_requests(requestType);
CREATE INDEX IF NOT EXISTS idx_approval_status ON approval_requests(status);
CREATE INDEX IF NOT EXISTS idx_approval_requested ON approval_requests(requestedBy);
CREATE INDEX IF NOT EXISTS idx_approval_date ON approval_requests(requestedAt);

-- Auto-approval rules configuration
CREATE TABLE IF NOT EXISTS approval_rules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ruleName TEXT NOT NULL,
    requestType TEXT NOT NULL,
    conditions TEXT NOT NULL, -- JSON: [{"field": "amount", "operator": "<=", "value": 100}]
    action TEXT DEFAULT 'auto_approve', -- 'auto_approve', 'require_approval', 'notify_only'
    assignTo INTEGER, -- User to notify/assign to
    isActive INTEGER DEFAULT 1,
    priority INTEGER DEFAULT 0, -- Rules checked in order
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER NOT NULL,
    notes TEXT,
    FOREIGN KEY (assignTo) REFERENCES users(id),
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_approval_rules_type ON approval_rules(requestType);
CREATE INDEX IF NOT EXISTS idx_approval_rules_active ON approval_rules(isActive);

-- ===================================
-- 5. STAFF MANAGEMENT
-- ===================================
-- Employee records

CREATE TABLE IF NOT EXISTS staff (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    userId INTEGER UNIQUE, -- Link to users table for login access
    employeeCode TEXT UNIQUE, -- e.g., 'EMP001', 'WAIT05'
    firstName TEXT NOT NULL,
    lastName TEXT NOT NULL,
    phone TEXT,
    email TEXT,
    position TEXT NOT NULL, -- 'bartender', 'waiter', 'chef', 'kitchen_staff', 'manager', 'cashier', 'cleaner'
    department TEXT, -- 'bar', 'kitchen', 'dining', 'management', 'cleaning'
    stationId INTEGER, -- Default station for kitchen/bar staff
    hireDate INTEGER NOT NULL,
    terminationDate INTEGER,
    employmentType TEXT DEFAULT 'full_time', -- 'full_time', 'part_time', 'contract', 'temporary'
    paymentType TEXT NOT NULL, -- 'monthly', 'daily', 'hourly'
    monthlySalary REAL DEFAULT 0,
    dailyRate REAL DEFAULT 0,
    hourlyRate REAL DEFAULT 0,
    overtimeRate REAL DEFAULT 0, -- Hourly overtime rate
    bankAccount TEXT,
    nationalId TEXT,
    address TEXT,
    emergencyContact TEXT,
    emergencyPhone TEXT,
    photo TEXT, -- File path or URL
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    notes TEXT,
    FOREIGN KEY (userId) REFERENCES users(id),
    FOREIGN KEY (stationId) REFERENCES production_stations(id)
);
CREATE INDEX IF NOT EXISTS idx_staff_user ON staff(userId);
CREATE INDEX IF NOT EXISTS idx_staff_position ON staff(position);
CREATE INDEX IF NOT EXISTS idx_staff_department ON staff(department);
CREATE INDEX IF NOT EXISTS idx_staff_active ON staff(isActive);

-- Staff attendance/time tracking
CREATE TABLE IF NOT EXISTS staff_attendance (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    staffId INTEGER NOT NULL,
    attendanceDate TEXT NOT NULL, -- YYYY-MM-DD
    checkInTime INTEGER,
    checkOutTime INTEGER,
    totalHours REAL DEFAULT 0,
    regularHours REAL DEFAULT 0,
    overtimeHours REAL DEFAULT 0,
    breakMinutes INTEGER DEFAULT 0,
    status TEXT DEFAULT 'present', -- 'present', 'absent', 'late', 'half_day', 'leave', 'holiday'
    leaveType TEXT, -- 'sick', 'vacation', 'personal', 'unpaid', 'emergency'
    approvalStatus TEXT DEFAULT 'pending', -- 'pending', 'approved', 'rejected' (for leaves/overtime)
    approvedBy INTEGER,
    approvedAt INTEGER,
    notes TEXT,
    FOREIGN KEY (staffId) REFERENCES staff(id),
    FOREIGN KEY (approvedBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_attendance_staff ON staff_attendance(staffId);
CREATE INDEX IF NOT EXISTS idx_attendance_date ON staff_attendance(attendanceDate);
CREATE INDEX IF NOT EXISTS idx_attendance_status ON staff_attendance(status);

-- Salary/wage payments
CREATE TABLE IF NOT EXISTS staff_payments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    staffId INTEGER NOT NULL,
    paymentType TEXT NOT NULL, -- 'salary', 'wages', 'bonus', 'overtime', 'commission', 'advance'
    paymentPeriod TEXT NOT NULL, -- 'January 2025', 'Dec 1-15, 2025'
    periodStart INTEGER,
    periodEnd INTEGER,
    baseAmount REAL DEFAULT 0,
    overtimeAmount REAL DEFAULT 0,
    bonusAmount REAL DEFAULT 0,
    commissionAmount REAL DEFAULT 0,
    deductions REAL DEFAULT 0, -- Taxes, advances, penalties
    netAmount REAL NOT NULL,
    paymentMethod TEXT DEFAULT 'cash', -- 'cash', 'bank_transfer', 'check'
    paymentDate INTEGER,
    status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'paid', 'cancelled'
    approvalRequired INTEGER DEFAULT 1,
    approvedBy INTEGER,
    approvedAt INTEGER,
    paidBy INTEGER,
    paidAt INTEGER,
    referenceNumber TEXT,
    receiptNumber TEXT,
    notes TEXT,
    FOREIGN KEY (staffId) REFERENCES staff(id),
    FOREIGN KEY (approvedBy) REFERENCES users(id),
    FOREIGN KEY (paidBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_staff_payments_staff ON staff_payments(staffId);
CREATE INDEX IF NOT EXISTS idx_staff_payments_period ON staff_payments(periodStart, periodEnd);
CREATE INDEX IF NOT EXISTS idx_staff_payments_status ON staff_payments(status);
CREATE INDEX IF NOT EXISTS idx_staff_payments_date ON staff_payments(paymentDate);

-- ===================================
-- 6. EXPENSES TRACKING
-- ===================================
-- All business expenses (including staff wages)

CREATE TABLE IF NOT EXISTS expenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    expenseCode TEXT UNIQUE,
    category TEXT NOT NULL, -- 'staff_wages', 'utilities', 'rent', 'supplies', 'maintenance', 'marketing', 'taxes', 'other'
    subcategory TEXT,
    description TEXT NOT NULL,
    amount REAL NOT NULL,
    expenseDate INTEGER NOT NULL,
    paymentMethod TEXT, -- 'cash', 'bank_transfer', 'credit_card', 'check'
    paymentReference TEXT,
    vendor TEXT,
    receiptNumber TEXT,
    receiptImage TEXT, -- File path
    referenceType TEXT, -- 'staff_payment', 'supplier_payment', 'manual', 'recurring'
    referenceId INTEGER,
    isRecurring INTEGER DEFAULT 0,
    recurringFrequency TEXT, -- 'daily', 'weekly', 'monthly', 'yearly'
    status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'paid', 'cancelled'
    approvalRequired INTEGER DEFAULT 0,
    approvedBy INTEGER,
    approvedAt INTEGER,
    paidBy INTEGER,
    paidAt INTEGER,
    recordedBy INTEGER NOT NULL,
    recordedAt INTEGER NOT NULL,
    notes TEXT,
    FOREIGN KEY (approvedBy) REFERENCES users(id),
    FOREIGN KEY (paidBy) REFERENCES users(id),
    FOREIGN KEY (recordedBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_expenses_category ON expenses(category);
CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(expenseDate);
CREATE INDEX IF NOT EXISTS idx_expenses_status ON expenses(status);
CREATE INDEX IF NOT EXISTS idx_expenses_reference ON expenses(referenceType, referenceId);

-- ===================================
-- 7. DINING AREA MANAGEMENT (Restaurant Mode)
-- ===================================
-- Restaurant floor layout and table management

CREATE TABLE IF NOT EXISTS dining_areas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL, -- 'Main Hall', 'Terrace', 'Bar Area', 'VIP Room'
    description TEXT,
    capacity INTEGER, -- Total seats
    floorLevel INTEGER DEFAULT 1,
    isActive INTEGER DEFAULT 1,
    displayOrder INTEGER DEFAULT 0,
    createdAt INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS dining_tables (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tableNumber TEXT NOT NULL UNIQUE, -- 'T01', 'T02', 'BAR-1'
    tableName TEXT, -- Optional friendly name
    areaId INTEGER NOT NULL,
    capacity INTEGER DEFAULT 4,
    tableType TEXT DEFAULT 'standard', -- 'standard', 'bar', 'booth', 'private', 'outdoor'
    status TEXT DEFAULT 'available', -- 'available', 'occupied', 'reserved', 'cleaning', 'closed'
    currentOrderId INTEGER, -- Link to active unpaid order
    assignedWaiterId INTEGER, -- Current waiter
    reservedBy TEXT, -- Customer name for reservations
    reservedAt INTEGER,
    reservedUntil INTEGER,
    lastCleaned INTEGER,
    xPosition INTEGER, -- For visual floor map
    yPosition INTEGER,
    isActive INTEGER DEFAULT 1,
    notes TEXT,
    FOREIGN KEY (areaId) REFERENCES dining_areas(id),
    FOREIGN KEY (assignedWaiterId) REFERENCES staff(id)
);
CREATE INDEX IF NOT EXISTS idx_tables_area ON dining_tables(areaId);
CREATE INDEX IF NOT EXISTS idx_tables_status ON dining_tables(status);
CREATE INDEX IF NOT EXISTS idx_tables_waiter ON dining_tables(assignedWaiterId);
CREATE INDEX IF NOT EXISTS idx_tables_active ON dining_tables(isActive);

-- ===================================
-- 8. PRODUCT TYPE ENHANCEMENTS
-- ===================================
-- Add columns to existing products table for production tracking

-- Add requiresProduction column to products table
-- 0 = Retail item (sold as-is, no production needed)
-- 1 = Produced item (needs recipe, goes to kitchen/bar)
ALTER TABLE products ADD COLUMN requiresProduction INTEGER DEFAULT 0;

-- Add default production station for products
ALTER TABLE products ADD COLUMN defaultStationId INTEGER;

-- ===================================
-- IMPLEMENTATION NOTES
-- ===================================
-- 
-- FLOW FOR STORE MODE (Current):
-- Suppliers ‚Üí Products (Stock) ‚Üí Sales ‚úÖ
--
-- FLOW FOR RESTAURANT MODE (Future):
-- 1. Purchase raw materials from suppliers ‚Üí raw_materials table
-- 2. Admin/Manager creates recipes ‚Üí recipes + recipe_ingredients
-- 3. Recipes link raw materials to menu items (products)
-- 4. Products appear in POS menu
-- 5. Customer orders ‚Üí Sale created
-- 6. Order sent to Kitchen/Bar ‚Üí station_orders
-- 7. Staff prepares item ‚Üí production_log created
-- 8. Raw materials auto-deducted ‚Üí raw_material_transactions
-- 9. Item marked ready ‚Üí served to customer
--
-- APPROVAL WORKFLOW:
-- - Purchase orders, refunds, bank transfers, staff payments require manager approval
-- - Auto-approval rules can bypass for small amounts
-- - All approvals tracked in approval_requests table
--
-- STAFF PAYROLL:
-- - Monthly: Fixed salary
-- - Daily: Days worked √ó daily rate
-- - Hourly: Hours worked √ó hourly rate (+ overtime)
-- - Payments create expense records automatically
--
-- ROLE-BASED ACCESS:
-- - Admin/Manager: Full access to all features
-- - Bartender: Bar station only, limited menu access
-- - Waiter: Table management, order taking
-- - Chef/Kitchen: Kitchen orders view only
-- - Cashier: POS operations only
--
-- ===================================

-- Record this migration
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (12, 'Future features: Raw materials, Production stations, Recipes, Approvals, Staff management, Expenses, Dining areas', strftime('%s', 'now') * 1000, 'system');
`
    },
    13: {
        version: 13,
        description: 'Add multi-currency support with exchange rates and conversion tracking',
        sql: `-- ===================================
-- AYN BEIRUT POS - MULTI-CURRENCY SYSTEM
-- Migration 013: Support for multiple currencies and exchange rates
-- ===================================
-- PREPARES DATABASE FOR FUTURE IMPLEMENTATION
-- Supports sales in multiple currencies with real-time conversion
-- Tracks exchange rate history and currency conversions
-- ===================================

-- ===================================
-- 1. CURRENCIES MASTER TABLE
-- ===================================
-- Stores all available currencies in the system

CREATE TABLE IF NOT EXISTS currencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE NOT NULL, -- ISO 4217: 'USD', 'EUR', 'LBP', etc.
    name TEXT NOT NULL, -- 'US Dollar', 'Lebanese Pound', etc.
    symbol TEXT NOT NULL, -- '\$', '‚Ç¨', 'ŸÑ.ŸÑ', etc.
    isBaseCurrency INTEGER DEFAULT 0, -- 1 if this is the base currency (usually USD)
    exchangeRate REAL DEFAULT 1.0, -- Rate to base currency (base = 1.0)
    decimalPlaces INTEGER DEFAULT 2, -- How many decimals to show (LBP = 0, USD = 2)
    position TEXT DEFAULT 'before', -- 'before' (\$100) or 'after' (100‚Ç¨)
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER,
    notes TEXT,
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_currencies_code ON currencies(code);
CREATE INDEX IF NOT EXISTS idx_currencies_active ON currencies(isActive);
CREATE INDEX IF NOT EXISTS idx_currencies_base ON currencies(isBaseCurrency);

-- ===================================
-- 2. EXCHANGE RATE HISTORY
-- ===================================
-- Track all exchange rate changes over time
-- Useful for historical reporting and auditing

CREATE TABLE IF NOT EXISTS exchange_rate_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    currencyId INTEGER NOT NULL,
    currencyCode TEXT NOT NULL,
    oldRate REAL,
    newRate REAL NOT NULL,
    changePercentage REAL, -- % change from old to new rate
    effectiveDate INTEGER NOT NULL, -- When this rate became effective
    changedBy INTEGER NOT NULL, -- User who updated the rate
    changedAt INTEGER NOT NULL,
    source TEXT, -- 'manual', 'api', 'bank', 'central_bank'
    notes TEXT,
    FOREIGN KEY (currencyId) REFERENCES currencies(id),
    FOREIGN KEY (changedBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_exchange_history_currency ON exchange_rate_history(currencyId);
CREATE INDEX IF NOT EXISTS idx_exchange_history_date ON exchange_rate_history(effectiveDate);
CREATE INDEX IF NOT EXISTS idx_exchange_history_code ON exchange_rate_history(currencyCode);

-- ===================================
-- 3. SALE CURRENCIES
-- ===================================
-- Store currency information for each sale
-- Links sales table to currencies used in that transaction

CREATE TABLE IF NOT EXISTS sale_currencies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    saleId INTEGER NOT NULL,
    currencyId INTEGER NOT NULL,
    currencyCode TEXT NOT NULL,
    exchangeRate REAL NOT NULL, -- Rate used at time of sale
    totalInCurrency REAL NOT NULL, -- Sale total in this currency
    totalInBaseCurrency REAL NOT NULL, -- Converted to base currency for reporting
    isPrimaryCurrency INTEGER DEFAULT 1, -- 1 if customer paid in this currency
    paymentAmount REAL, -- Amount paid in this currency (if split payment)
    changeAmount REAL, -- Change given in this currency
    createdAt INTEGER NOT NULL,
    FOREIGN KEY (saleId) REFERENCES sales(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES currencies(id)
);
CREATE INDEX IF NOT EXISTS idx_sale_currencies_sale ON sale_currencies(saleId);
CREATE INDEX IF NOT EXISTS idx_sale_currencies_currency ON sale_currencies(currencyId);
CREATE INDEX IF NOT EXISTS idx_sale_currencies_code ON sale_currencies(currencyCode);
CREATE INDEX IF NOT EXISTS idx_sale_currencies_date ON sale_currencies(createdAt);

-- ===================================
-- 4. PRODUCT PRICES (MULTI-CURRENCY)
-- ===================================
-- Allow products to have prices in multiple currencies
-- Override default conversion with custom prices

CREATE TABLE IF NOT EXISTS product_prices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL,
    currencyId INTEGER NOT NULL,
    currencyCode TEXT NOT NULL,
    price REAL NOT NULL, -- Price in this specific currency
    compareAtPrice REAL, -- Original price (for showing discounts)
    costPrice REAL, -- Cost in this currency (for profit calculation)
    isAutoCalculated INTEGER DEFAULT 1, -- 1 = auto-convert, 0 = manually set
    effectiveDate INTEGER, -- When this price becomes active
    expiryDate INTEGER, -- When this price expires (for promotions)
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER,
    notes TEXT,
    FOREIGN KEY (productId) REFERENCES products(id) ON DELETE CASCADE,
    FOREIGN KEY (currencyId) REFERENCES currencies(id),
    FOREIGN KEY (createdBy) REFERENCES users(id),
    UNIQUE(productId, currencyId) -- Each product can have only one active price per currency
);
CREATE INDEX IF NOT EXISTS idx_product_prices_product ON product_prices(productId);
CREATE INDEX IF NOT EXISTS idx_product_prices_currency ON product_prices(currencyId);
CREATE INDEX IF NOT EXISTS idx_product_prices_code ON product_prices(currencyCode);
CREATE INDEX IF NOT EXISTS idx_product_prices_active ON product_prices(isActive);

-- ===================================
-- 5. CURRENCY CONVERSIONS LOG
-- ===================================
-- Track when users manually convert amounts
-- Useful for audit trail and analytics

CREATE TABLE IF NOT EXISTS currency_conversions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    fromCurrencyId INTEGER NOT NULL,
    fromCurrencyCode TEXT NOT NULL,
    toCurrencyId INTEGER NOT NULL,
    toCurrencyCode TEXT NOT NULL,
    fromAmount REAL NOT NULL,
    toAmount REAL NOT NULL,
    exchangeRate REAL NOT NULL,
    conversionType TEXT DEFAULT 'manual', -- 'manual', 'sale', 'payment', 'refund', 'report'
    referenceType TEXT, -- 'sale', 'refund', 'expense', etc.
    referenceId INTEGER, -- Link to related transaction
    convertedBy INTEGER NOT NULL,
    convertedAt INTEGER NOT NULL,
    notes TEXT,
    FOREIGN KEY (fromCurrencyId) REFERENCES currencies(id),
    FOREIGN KEY (toCurrencyId) REFERENCES currencies(id),
    FOREIGN KEY (convertedBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_conversions_from ON currency_conversions(fromCurrencyId);
CREATE INDEX IF NOT EXISTS idx_conversions_to ON currency_conversions(toCurrencyId);
CREATE INDEX IF NOT EXISTS idx_conversions_date ON currency_conversions(convertedAt);
CREATE INDEX IF NOT EXISTS idx_conversions_type ON currency_conversions(conversionType);
CREATE INDEX IF NOT EXISTS idx_conversions_reference ON currency_conversions(referenceType, referenceId);

-- ===================================
-- 6. DEFAULT CURRENCY DATA
-- ===================================
-- Insert commonly used Middle East & international currencies
-- USD is set as base currency

INSERT OR IGNORE INTO currencies (code, name, symbol, isBaseCurrency, exchangeRate, decimalPlaces, position, isActive, createdAt, updatedAt, notes) VALUES
('USD', 'US Dollar', '\$', 1, 1.0, 2, 'before', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Base currency for all conversions'),
('EUR', 'Euro', '‚Ç¨', 0, 0.92, 2, 'before', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'European Union currency'),
('GBP', 'British Pound', '¬£', 0, 0.79, 2, 'before', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'United Kingdom currency'),
('LBP', 'Lebanese Pound', 'ŸÑ.ŸÑ', 0, 89500.0, 0, 'after', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Lebanese Pound - high inflation, no decimals'),
('AED', 'UAE Dirham', 'ÿØ.ÿ•', 0, 3.67, 2, 'after', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'United Arab Emirates currency'),
('SAR', 'Saudi Riyal', 'ÿ±.ÿ≥', 0, 3.75, 2, 'after', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Saudi Arabia currency'),
('EGP', 'Egyptian Pound', 'ÿ¨.ŸÖ', 0, 30.90, 2, 'after', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Egyptian currency'),
('TRY', 'Turkish Lira', '‚Ç∫', 0, 32.50, 2, 'before', 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Turkish currency');

-- ===================================
-- IMPLEMENTATION TASKS (FUTURE)
-- ===================================
-- TODO: Create currency management UI in Admin Dashboard
-- TODO: Add exchange rate auto-update from API (xe.com, fixer.io, etc.)
-- TODO: Add currency selector to POS interface
-- TODO: Update sales.js to handle multi-currency payments
-- TODO: Create currency conversion calculator tool
-- TODO: Add multi-currency reports (daily sales by currency)
-- TODO: Implement split payment in multiple currencies
-- TODO: Add currency rounding rules (LBP rounds to nearest 250/500)
-- TODO: Create exchange rate alert system (notify on major changes)
-- TODO: Add historical exchange rate charts
-- TODO: Implement automatic price updates when rates change
-- TODO: Add currency-specific tax handling
-- ===================================
`
    },
    14: {
        version: 14,
        description: 'Add discount rules, loyalty tiers, and promotional codes system',
        sql: `-- ===================================
-- AYN BEIRUT POS - DISCOUNT & OFFERS SYSTEM
-- Migration 014: Comprehensive discount and promotional system
-- ===================================
-- PREPARES DATABASE FOR FUTURE IMPLEMENTATION
-- Supports multiple discount types, loyalty programs, and promotional codes
-- Includes time-based restrictions and usage tracking
-- ===================================

-- ===================================
-- 1. DISCOUNT RULES MASTER TABLE
-- ===================================
-- Central table for all discount configurations

CREATE TABLE IF NOT EXISTS discount_rules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE NOT NULL, -- 'SUMMER2024', 'BOGO', 'HAPPY_HOUR', etc.
    name TEXT NOT NULL, -- Display name
    description TEXT,
    type TEXT NOT NULL, -- 'percentage', 'fixed_amount', 'buy_x_get_y', 'free_shipping', 'bundle'
    value REAL NOT NULL, -- Discount value (10 for 10%, 5.00 for \$5 off)
    startDate INTEGER, -- When discount becomes active (NULL = immediate)
    endDate INTEGER, -- When discount expires (NULL = no expiry)
    isActive INTEGER DEFAULT 1,
    
    -- Minimum purchase requirements
    minPurchaseAmount REAL DEFAULT 0, -- Minimum cart total to apply discount
    minQuantity INTEGER DEFAULT 0, -- Minimum items needed
    maxDiscountAmount REAL, -- Cap the discount at this amount
    
    -- Product/Category restrictions
    applicableToProductIds TEXT, -- JSON array of product IDs: '[1,2,3]'
    applicableToCategories TEXT, -- JSON array of categories: '["Coffee","Sandwiches"]'
    excludedProductIds TEXT, -- JSON array of excluded products
    excludedCategories TEXT, -- JSON array of excluded categories
    
    -- Time restrictions
    dayOfWeek TEXT, -- JSON array: '["monday","tuesday"]' or NULL for all days
    timeOfDayStart TEXT, -- '09:00' - start time (24h format)
    timeOfDayEnd TEXT, -- '17:00' - end time
    
    -- Buy X Get Y specifics
    buyQuantity INTEGER, -- Buy this many
    getQuantity INTEGER, -- Get this many free/discounted
    getDiscountPercentage REAL DEFAULT 100, -- 100 = free, 50 = half price
    
    -- Usage limits
    maxUsesTotal INTEGER, -- Total times this discount can be used (NULL = unlimited)
    maxUsesPerCustomer INTEGER, -- Times each customer can use (NULL = unlimited)
    currentUsageCount INTEGER DEFAULT 0, -- Track total uses
    
    -- Priority & Stacking
    priority INTEGER DEFAULT 0, -- Higher priority discounts apply first
    canCombineWithOthers INTEGER DEFAULT 0, -- Can be used with other discounts
    
    -- Loyalty tier restrictions
    minLoyaltyTier TEXT, -- 'bronze', 'silver', 'gold' - minimum tier required
    
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    createdBy INTEGER NOT NULL,
    notes TEXT,
    
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_discount_rules_code ON discount_rules(code);
CREATE INDEX IF NOT EXISTS idx_discount_rules_type ON discount_rules(type);
CREATE INDEX IF NOT EXISTS idx_discount_rules_active ON discount_rules(isActive);
CREATE INDEX IF NOT EXISTS idx_discount_rules_dates ON discount_rules(startDate, endDate);
CREATE INDEX IF NOT EXISTS idx_discount_rules_priority ON discount_rules(priority);

-- ===================================
-- 2. DISCOUNT USAGES LOG
-- ===================================
-- Track every time a discount is applied to a sale

CREATE TABLE IF NOT EXISTS discount_usages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    discountRuleId INTEGER NOT NULL,
    discountCode TEXT NOT NULL,
    saleId INTEGER, -- NULL if sale not completed
    unpaidOrderId INTEGER, -- Link to unpaid order if applicable
    customerId INTEGER, -- Track customer usage
    
    originalAmount REAL NOT NULL, -- Price before discount
    discountAmount REAL NOT NULL, -- Amount discounted
    finalAmount REAL NOT NULL, -- Price after discount
    
    appliedAt INTEGER NOT NULL,
    appliedBy INTEGER NOT NULL, -- User/cashier who applied it
    
    -- Context information
    itemsAffected TEXT, -- JSON array of product IDs affected
    quantityAffected INTEGER, -- How many items got the discount
    
    status TEXT DEFAULT 'applied', -- 'applied', 'cancelled', 'refunded'
    cancelledAt INTEGER,
    cancelledBy INTEGER,
    cancellationReason TEXT,
    
    notes TEXT,
    
    FOREIGN KEY (discountRuleId) REFERENCES discount_rules(id),
    FOREIGN KEY (saleId) REFERENCES sales(id) ON DELETE SET NULL,
    FOREIGN KEY (customerId) REFERENCES customers(id),
    FOREIGN KEY (appliedBy) REFERENCES users(id),
    FOREIGN KEY (cancelledBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_discount_usages_rule ON discount_usages(discountRuleId);
CREATE INDEX IF NOT EXISTS idx_discount_usages_sale ON discount_usages(saleId);
CREATE INDEX IF NOT EXISTS idx_discount_usages_customer ON discount_usages(customerId);
CREATE INDEX IF NOT EXISTS idx_discount_usages_date ON discount_usages(appliedAt);
CREATE INDEX IF NOT EXISTS idx_discount_usages_status ON discount_usages(status);

-- ===================================
-- 3. PRODUCT DISCOUNTS (QUICK ASSIGN)
-- ===================================
-- Link specific products to specific discounts for faster lookups

CREATE TABLE IF NOT EXISTS product_discounts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL,
    discountRuleId INTEGER NOT NULL,
    
    isActive INTEGER DEFAULT 1,
    effectiveDate INTEGER, -- When this product discount becomes active
    expiryDate INTEGER, -- When it expires
    
    displayInPOS INTEGER DEFAULT 1, -- Show in POS discount menu
    displayBadge TEXT, -- 'SALE', '50% OFF', 'NEW', etc.
    displayColor TEXT, -- Badge color: 'red', 'green', 'blue'
    
    createdAt INTEGER NOT NULL,
    createdBy INTEGER,
    
    FOREIGN KEY (productId) REFERENCES products(id) ON DELETE CASCADE,
    FOREIGN KEY (discountRuleId) REFERENCES discount_rules(id) ON DELETE CASCADE,
    FOREIGN KEY (createdBy) REFERENCES users(id),
    UNIQUE(productId, discountRuleId) -- Prevent duplicate assignments
);
CREATE INDEX IF NOT EXISTS idx_product_discounts_product ON product_discounts(productId);
CREATE INDEX IF NOT EXISTS idx_product_discounts_rule ON product_discounts(discountRuleId);
CREATE INDEX IF NOT EXISTS idx_product_discounts_active ON product_discounts(isActive);

-- ===================================
-- 4. LOYALTY TIERS
-- ===================================
-- Customer loyalty program tiers with different benefits

CREATE TABLE IF NOT EXISTS loyalty_tiers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL, -- 'Bronze', 'Silver', 'Gold', 'Platinum'
    code TEXT UNIQUE NOT NULL, -- 'bronze', 'silver', 'gold', 'platinum'
    description TEXT,
    
    -- Qualification criteria
    minPurchaseAmount REAL DEFAULT 0, -- Lifetime spending required
    minTransactionCount INTEGER DEFAULT 0, -- Number of purchases required
    minPointsRequired INTEGER DEFAULT 0, -- Loyalty points needed
    
    -- Benefits
    discountPercentage REAL DEFAULT 0, -- Automatic discount on all purchases
    pointsMultiplier REAL DEFAULT 1.0, -- 1.5 = earn 50% more points
    
    -- Tier privileges
    birthdayBonus REAL DEFAULT 0, -- Special birthday discount
    freeDelivery INTEGER DEFAULT 0, -- Free delivery for this tier
    prioritySupport INTEGER DEFAULT 0, -- Priority customer service
    exclusiveOffers INTEGER DEFAULT 0, -- Access to exclusive deals
    
    -- Display
    color TEXT, -- '#CD7F32' (bronze), '#C0C0C0' (silver), '#FFD700' (gold)
    icon TEXT, -- Emoji or icon name
    displayOrder INTEGER DEFAULT 0, -- Sort order in UI
    
    isActive INTEGER DEFAULT 1,
    createdAt INTEGER NOT NULL,
    updatedAt INTEGER NOT NULL,
    
    notes TEXT
);
CREATE INDEX IF NOT EXISTS idx_loyalty_tiers_code ON loyalty_tiers(code);
CREATE INDEX IF NOT EXISTS idx_loyalty_tiers_active ON loyalty_tiers(isActive);
CREATE INDEX IF NOT EXISTS idx_loyalty_tiers_order ON loyalty_tiers(displayOrder);

-- ===================================
-- 5. PROMOTIONAL CODES (COUPONS)
-- ===================================
-- Unique coupon codes with usage limits

CREATE TABLE IF NOT EXISTS promotional_codes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE NOT NULL, -- 'WELCOME10', 'FRIEND20', etc.
    discountRuleId INTEGER NOT NULL, -- Links to discount_rules
    
    -- Usage limits
    maxUses INTEGER, -- Total uses allowed (NULL = unlimited)
    usesRemaining INTEGER, -- Current remaining uses
    maxUsesPerCustomer INTEGER DEFAULT 1, -- Per-customer limit
    
    -- Validity period
    validFrom INTEGER, -- Start date
    validUntil INTEGER, -- Expiry date
    
    -- Distribution tracking
    distributionChannel TEXT, -- 'email', 'social_media', 'in_store', 'affiliate'
    distributionDate INTEGER, -- When codes were distributed
    targetAudience TEXT, -- 'new_customers', 'vip', 'birthday', etc.
    
    isActive INTEGER DEFAULT 1,
    isSingleUse INTEGER DEFAULT 0, -- 1 = code deactivates after first use
    
    createdAt INTEGER NOT NULL,
    createdBy INTEGER NOT NULL,
    
    notes TEXT,
    
    FOREIGN KEY (discountRuleId) REFERENCES discount_rules(id),
    FOREIGN KEY (createdBy) REFERENCES users(id)
);
CREATE INDEX IF NOT EXISTS idx_promo_codes_code ON promotional_codes(code);
CREATE INDEX IF NOT EXISTS idx_promo_codes_rule ON promotional_codes(discountRuleId);
CREATE INDEX IF NOT EXISTS idx_promo_codes_active ON promotional_codes(isActive);
CREATE INDEX IF NOT EXISTS idx_promo_codes_validity ON promotional_codes(validFrom, validUntil);

-- ===================================
-- 6. DEFAULT LOYALTY TIERS DATA
-- ===================================
-- Insert standard loyalty tier structure

INSERT OR IGNORE INTO loyalty_tiers (name, code, description, minPurchaseAmount, minTransactionCount, discountPercentage, pointsMultiplier, color, icon, displayOrder, isActive, createdAt, updatedAt, notes) VALUES
('Bronze', 'bronze', 'Entry level - Welcome to our loyalty program!', 0, 0, 0, 1.0, '#CD7F32', 'ü•â', 1, 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Automatic tier for all customers'),
('Silver', 'silver', 'Silver members enjoy 5% discount', 500, 10, 5, 1.2, '#C0C0C0', 'ü•à', 2, 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Spend \$500 or make 10 purchases'),
('Gold', 'gold', 'Gold members get 10% discount + exclusive offers', 2000, 30, 10, 1.5, '#FFD700', 'ü•á', 3, 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Spend \$2000 or make 30 purchases'),
('Platinum', 'platinum', 'VIP treatment with 15% discount + free delivery', 5000, 50, 15, 2.0, '#E5E4E2', 'üíé', 4, 1, strftime('%s', 'now'), strftime('%s', 'now'), 'Spend \$5000 or make 50 purchases');

-- ===================================
-- 7. DEFAULT DISCOUNT EXAMPLES
-- ===================================
-- Sample discount rules to demonstrate system capabilities

INSERT OR IGNORE INTO discount_rules (code, name, description, type, value, isActive, minPurchaseAmount, maxDiscountAmount, dayOfWeek, timeOfDayStart, timeOfDayEnd, priority, canCombineWithOthers, createdAt, updatedAt, createdBy, notes) VALUES
('HAPPY_HOUR', 'Happy Hour 20% Off', 'Get 20% off on all beverages between 2 PM and 5 PM', 'percentage', 20, 1, 0, NULL, '["monday","tuesday","wednesday","thursday","friday"]', '14:00', '17:00', 5, 0, strftime('%s', 'now'), strftime('%s', 'now'), 1, 'Afternoon discount to boost slow hours'),
('WEEKEND_SPECIAL', 'Weekend Special 10%', 'Enjoy 10% off on weekends', 'percentage', 10, 1, 0, NULL, '["saturday","sunday"]', NULL, NULL, 3, 1, strftime('%s', 'now'), strftime('%s', 'now'), 1, 'Weekend promotion'),
('BOGO_COFFEE', 'Buy One Get One Coffee', 'Buy one coffee, get second one free', 'buy_x_get_y', 0, 1, 0, NULL, NULL, NULL, NULL, 8, 0, strftime('%s', 'now'), strftime('%s', 'now'), 1, 'Popular coffee promotion');

-- ===================================
-- 8. SAMPLE PROMOTIONAL CODES
-- ===================================
-- Pre-configured coupon codes ready to use

INSERT OR IGNORE INTO promotional_codes (code, discountRuleId, maxUses, usesRemaining, maxUsesPerCustomer, validFrom, validUntil, distributionChannel, isActive, isSingleUse, createdAt, createdBy, notes) VALUES
('WELCOME10', (SELECT id FROM discount_rules WHERE code = 'WEEKEND_SPECIAL'), 100, 100, 1, strftime('%s', 'now'), strftime('%s', 'now', '+30 days'), 'email', 1, 0, strftime('%s', 'now'), 1, 'New customer welcome code'),
('VIP2024', (SELECT id FROM discount_rules WHERE code = 'WEEKEND_SPECIAL'), 50, 50, 3, strftime('%s', 'now'), strftime('%s', 'now', '+90 days'), 'in_store', 1, 0, strftime('%s', 'now'), 1, 'VIP customer exclusive code');

-- ===================================
-- IMPLEMENTATION TASKS (FUTURE)
-- ===================================
-- TODO: Create discount management UI (add/edit/delete rules)
-- TODO: Add discount picker widget in POS interface
-- TODO: Implement automatic discount application logic
-- TODO: Create discount conflict resolution (priority system)
-- TODO: Add discount preview before checkout
-- TODO: Implement coupon code validation in POS
-- TODO: Create discount performance analytics dashboard
-- TODO: Add A/B testing for different discount strategies
-- TODO: Implement customer loyalty tier auto-upgrade
-- TODO: Create discount effectiveness reports (ROI tracking)
-- TODO: Add scheduled discount activation/deactivation
-- TODO: Implement flash sales and limited-time offers
-- TODO: Create discount notification system (customer alerts)
-- TODO: Add discount approval workflow for large discounts
-- TODO: Implement referral discount program
-- TODO: Create bundle discount builder (product combos)
-- TODO: Add quantity-based tiered discounts
-- TODO: Implement birthday month automatic discounts
-- ===================================
`
    },
    15: {
        version: 15,
        description: 'Add raw materials support with unit types and decimal stock quantities',
        sql: `-- =====================================================
-- MIGRATION 015: ADD RAW MATERIALS WITH UNITS
-- Adds raw_material product type with unit support
-- Changes stock to REAL for decimal quantities
-- =====================================================

-- Step 1: Add raw_material to product type check constraint
-- SQLite doesn't support DROP CONSTRAINT or ALTER COLUMN
-- We use triggers to validate the new enum values

-- Add new constraint including raw_material
CREATE TRIGGER IF NOT EXISTS validate_product_type_insert
BEFORE INSERT ON products
FOR EACH ROW
WHEN NEW.type NOT IN ('item', 'service', 'raw_material')
BEGIN
    SELECT RAISE(ABORT, 'Invalid product type. Must be: item, service, or raw_material');
END;

CREATE TRIGGER IF NOT EXISTS validate_product_type_update
BEFORE UPDATE ON products
FOR EACH ROW
WHEN NEW.type NOT IN ('item', 'service', 'raw_material')
BEGIN
    SELECT RAISE(ABORT, 'Invalid product type. Must be: item, service, or raw_material');
END;

-- Step 2: Add unit column for raw materials
ALTER TABLE products ADD COLUMN unit TEXT DEFAULT 'pieces' 
    CHECK(unit IN ('kg', 'g', 'litre', 'ml', 'meter', 'cm', 'pieces'));

-- Step 3: Create new table with REAL stock column
CREATE TABLE products_new (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT NOT NULL,
    price REAL NOT NULL,
    cost REAL DEFAULT 0,
    type TEXT DEFAULT 'item',
    unit TEXT DEFAULT 'pieces' CHECK(unit IN ('kg', 'g', 'litre', 'ml', 'meter', 'cm', 'pieces')),
    icon TEXT,
    barcode TEXT UNIQUE,
    stock REAL DEFAULT 0,  -- Changed from INTEGER to REAL
    hourlyEnabled INTEGER DEFAULT 0,
    firstHourRate REAL DEFAULT 0,
    additionalHourRate REAL DEFAULT 0,
    description TEXT,
    createdAt INTEGER,
    updatedAt INTEGER,
    synced INTEGER DEFAULT 0,
    synced_at INTEGER
);

-- Copy data from old table
INSERT INTO products_new SELECT 
    id, name, category, price, cost, type, 
    COALESCE(unit, 'pieces') as unit,
    icon, barcode, 
    CAST(stock AS REAL) as stock,  -- Convert INTEGER to REAL
    hourlyEnabled, firstHourRate, additionalHourRate,
    description, createdAt, updatedAt, synced, synced_at
FROM products;

-- Drop old table and rename new one
DROP TABLE products;
ALTER TABLE products_new RENAME TO products;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
CREATE INDEX IF NOT EXISTS idx_products_barcode ON products(barcode);
CREATE INDEX IF NOT EXISTS idx_products_type ON products(type);
CREATE INDEX IF NOT EXISTS idx_products_synced ON products(synced);

-- Step 4: Update stock_history table to support REAL quantities
CREATE TABLE stock_history_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    oldStock REAL,  -- Changed from INTEGER to REAL
    newStock REAL NOT NULL,  -- Changed from INTEGER to REAL
    quantity REAL,  -- Changed from INTEGER to REAL
    reason TEXT,
    type TEXT CHECK(type IN ('add', 'remove', 'sale', 'adjustment')),
    userId INTEGER,
    cashierId INTEGER
);

-- Copy existing stock history data
INSERT INTO stock_history_new SELECT 
    id, productId, timestamp,
    CAST(oldStock AS REAL) as oldStock,
    CAST(newStock AS REAL) as newStock,
    CAST(quantity AS REAL) as quantity,
    reason, type, userId, cashierId
FROM stock_history;

-- Drop old table and rename
DROP TABLE stock_history;
ALTER TABLE stock_history_new RENAME TO stock_history;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_stock_history_product ON stock_history(productId);
CREATE INDEX IF NOT EXISTS idx_stock_history_timestamp ON stock_history(timestamp);

-- Step 5: Update delivery_items to support REAL quantities
CREATE TABLE delivery_items_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    deliveryId INTEGER NOT NULL,
    productId INTEGER NOT NULL,
    quantity REAL NOT NULL,  -- Changed from INTEGER to REAL
    unitCost REAL NOT NULL,
    lineTotal REAL NOT NULL
);

-- Copy existing delivery data
INSERT INTO delivery_items_new SELECT 
    id, deliveryId, productId,
    CAST(quantity AS REAL) as quantity,
    unitCost, lineTotal
FROM delivery_items;

-- Drop old table and rename
DROP TABLE delivery_items;
ALTER TABLE delivery_items_new RENAME TO delivery_items;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_delivery_items_delivery ON delivery_items(deliveryId);
CREATE INDEX IF NOT EXISTS idx_delivery_items_product ON delivery_items(productId);

-- Step 6: Record migration
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (15, 'Add raw materials with units and decimal stock support', datetime('now'), 'system');

-- Migration complete
SELECT 'Migration 015 completed successfully' as status;
`
    },
    16: {
        version: 16,
        description: 'Add refund tracking columns and update stock_history to support refund type',
        sql: `-- =====================================================
-- MIGRATION 016: ADD REFUND TRACKING TO SALES
-- Links sales to refunds and updates stock_history
-- =====================================================

-- Step 1: Add refund tracking columns to sales table
ALTER TABLE sales ADD COLUMN refundId INTEGER;
ALTER TABLE sales ADD COLUMN refundedAt INTEGER;

-- Create index for refund lookups
CREATE INDEX IF NOT EXISTS idx_sales_refund ON sales(refundId);

-- Step 2: Update stock_history type enum to include 'refund'
-- SQLite doesn't support ALTER COLUMN on CHECK constraints
-- We need to recreate the table with updated constraint

-- Create new stock_history table with 'refund' type included
CREATE TABLE stock_history_temp (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    productId INTEGER NOT NULL,
    timestamp INTEGER NOT NULL,
    oldStock REAL,
    newStock REAL NOT NULL,
    quantity REAL,
    reason TEXT,
    type TEXT CHECK(type IN ('add', 'remove', 'sale', 'adjustment', 'refund')),
    userId INTEGER,
    cashierId INTEGER
);

-- Copy existing data
INSERT INTO stock_history_temp 
SELECT id, productId, timestamp, oldStock, newStock, quantity, reason, type, userId, cashierId
FROM stock_history;

-- Drop old table
DROP TABLE stock_history;

-- Rename new table
ALTER TABLE stock_history_temp RENAME TO stock_history;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_stock_history_product ON stock_history(productId);
CREATE INDEX IF NOT EXISTS idx_stock_history_timestamp ON stock_history(timestamp);

-- Step 3: Add foreign key index to refunds table (if not exists)
CREATE INDEX IF NOT EXISTS idx_refunds_sale ON refunds(saleId);

-- Step 4: Create view for sales with refund information
CREATE VIEW IF NOT EXISTS sales_with_refunds AS
SELECT 
    s.*,
    r.id as refund_id,
    r.refundAmount,
    r.refundType,
    r.refundItems,
    r.timestamp as refund_timestamp,
    r.reason as refund_reason,
    r.approverUsername as refund_approver
FROM sales s
LEFT JOIN refunds r ON s.refundId = r.id;

-- Step 5: Record schema version update
INSERT INTO schema_version (version, description, applied_at, applied_by)
VALUES (16, 'Add refund tracking to sales table and update stock_history type enum', 
        strftime('%s', 'now') * 1000, 'system');

-- Verification queries
SELECT '‚úÖ Migration 016 applied successfully' as status;
SELECT 'Schema version: ' || MAX(version) as version FROM schema_version;
`
    },
    17: {
        version: 17,
        description: 'Add payment terms, balance caching, visit tracking, and configurable settings',
        sql: `-- Migration 017: Supplier & Client Financial Tracking System
-- Add payment terms, balance caching, visit tracking, and settings

-- 1. Note: payment_terms_days column added via JavaScript with error handling

-- 2. Create supplier_balances_cache table for performance
CREATE TABLE IF NOT EXISTS supplier_balances_cache (
    supplier_id INTEGER PRIMARY KEY,
    total_purchases REAL DEFAULT 0,
    total_paid REAL DEFAULT 0,
    balance_owed REAL DEFAULT 0,
    last_delivery_date TEXT,
    last_payment_date TEXT,
    last_updated TEXT DEFAULT (datetime('now')),
    cache_expires_at TEXT DEFAULT (datetime('now', '+24 hours')),
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_supplier_balances_cache_expires ON supplier_balances_cache(cache_expires_at);
CREATE INDEX IF NOT EXISTS idx_supplier_balances_cache_balance ON supplier_balances_cache(balance_owed);

-- 3. Note: last_visit_date column added via JavaScript with error handling

-- Note: Cannot easily update last_visit_date from sales.customerInfo (JSON column)
-- This will be handled by application code when customers are linked to sales

CREATE INDEX IF NOT EXISTS idx_customers_last_visit ON customers(last_visit_date);

-- 4. Create settings table for configurable thresholds
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    description TEXT,
    updated_at TEXT DEFAULT (datetime('now'))
);

-- Insert default visit threshold settings
INSERT OR IGNORE INTO settings (key, value, description) VALUES 
    ('client_active_threshold_days', '30', 'Days threshold for marking clients as ACTIVE'),
    ('client_occasional_threshold_days', '90', 'Days threshold for marking clients as OCCASIONAL vs INACTIVE');

-- 5. Note: payment_terms_days defaults to 30 days, can be updated via UI

-- 6. Create function view for supplier status (for reporting)
CREATE VIEW IF NOT EXISTS supplier_status_view AS
SELECT 
    s.id,
    s.name,
    s.payment_terms_days,
    sbc.total_purchases,
    sbc.total_paid,
    sbc.balance_owed,
    sbc.last_delivery_date,
    CASE 
        WHEN sbc.last_delivery_date IS NOT NULL THEN
            date(sbc.last_delivery_date, '+' || s.payment_terms_days || ' days')
        ELSE NULL
    END as due_date,
    CASE
        WHEN sbc.balance_owed = 0 THEN 'PAID'
        WHEN sbc.last_delivery_date IS NOT NULL AND 
             date(sbc.last_delivery_date, '+' || s.payment_terms_days || ' days') < date('now') 
             AND sbc.balance_owed > 0 
        THEN 'OVERDUE'
        WHEN sbc.last_delivery_date IS NOT NULL AND 
             date(sbc.last_delivery_date, '+' || s.payment_terms_days || ' days') BETWEEN date('now') AND date('now', '+7 days')
             AND sbc.balance_owed > 0
        THEN 'DUE_SOON'
        ELSE 'CURRENT'
    END as status
FROM suppliers s
LEFT JOIN supplier_balances_cache sbc ON s.id = sbc.supplier_id;

-- 7. Create view for client status (for reporting)
CREATE VIEW IF NOT EXISTS client_status_view AS
SELECT 
    c.id,
    c.name,
    c.last_visit_date,
    CASE
        WHEN c.last_visit_date IS NULL THEN 'NEVER_VISITED'
        WHEN julianday('now') - julianday(c.last_visit_date) <= 
             (SELECT CAST(value AS INTEGER) FROM settings WHERE key = 'client_active_threshold_days')
        THEN 'ACTIVE'
        WHEN julianday('now') - julianday(c.last_visit_date) <= 
             (SELECT CAST(value AS INTEGER) FROM settings WHERE key = 'client_occasional_threshold_days')
        THEN 'OCCASIONAL'
        ELSE 'INACTIVE'
    END as status,
    CAST(julianday('now') - julianday(c.last_visit_date) AS INTEGER) as days_since_visit
FROM customers c;

-- 8. Note: Trigger for updating last_visit_date skipped as sales table uses JSON customerInfo
-- This will be handled by application code when customers are linked to sales

-- 9. Add payment_impact column to supplier_payments for tracking payment effectiveness
-- Note: Skipping as column may not be needed yet

-- 10. Note: Indexes already exist with camelCase naming from migration 001
-- Skipping duplicate index creation to avoid errors
`
    },
    18: {
        version: 18,
        description: 'Add recipe system for composed products with ingredient tracking and cost snapshots',
        sql: `-- Migration 018: Add Product Recipes and Recipe Snapshots
-- Date: 2025-12-22
-- Description: Support for composed products with ingredient recipes and historical cost tracking

-- Product Recipes Table
-- Defines the ingredients (raw materials) that compose a product
CREATE TABLE IF NOT EXISTS product_recipes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER NOT NULL,
    raw_material_id INTEGER NOT NULL,
    quantity REAL NOT NULL,
    unit TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    FOREIGN KEY (raw_material_id) REFERENCES products(id) ON DELETE RESTRICT
);

-- Sale Recipe Snapshots Table
-- Captures the recipe composition and costs at the time of sale
-- This ensures accurate historical COGS calculations even if ingredient costs change
CREATE TABLE IF NOT EXISTS sale_recipe_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sale_id INTEGER NOT NULL,
    sale_item_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    raw_material_id INTEGER NOT NULL,
    raw_material_name TEXT NOT NULL,
    quantity REAL NOT NULL,
    unit TEXT NOT NULL,
    cost_per_unit REAL NOT NULL,
    total_cost REAL NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE RESTRICT,
    FOREIGN KEY (raw_material_id) REFERENCES products(id) ON DELETE RESTRICT
);

-- Add columns if they don't exist (check first to avoid errors)
-- SQLite doesn't support IF NOT EXISTS for ALTER TABLE, so we handle errors gracefully in code

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_product_recipes_product ON product_recipes(product_id);
CREATE INDEX IF NOT EXISTS idx_product_recipes_material ON product_recipes(raw_material_id);
CREATE INDEX IF NOT EXISTS idx_sale_snapshots_sale ON sale_recipe_snapshots(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_snapshots_product ON sale_recipe_snapshots(product_id);
`
    },
};

// Export for use in db-sql.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = BUNDLED_MIGRATIONS;
}
